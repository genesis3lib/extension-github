name: Appinfra-020-Bootstrap

on:
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  TF_VERSION: "1.12.2"
  AWS_REGION: {{region}}

jobs:
  bootstrap:
    name: Bootstrap Terraform State
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Env setup
        run: |
          
          # Set environment variables
          echo "BRANCH={{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" >> $GITHUB_ENV
          if [[ "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" = "main" || "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" = "production" ]]; then
            echo "ENVIRONMENT=prod" >> $GITHUB_ENV
          else 
            BRANCH_ENV=$(echo "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" | sed "s///-/g")
            echo "ENVIRONMENT=$BRANCH_ENV" >> $GITHUB_ENV
          fi
          
          echo "‚úÖ Environment setup completed: {{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:role/{{projectName}}-terraform-role
          aws-region: {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: {{{githubVarsOpen}}} env.TF_VERSION  {{{githubVarsClose}}}
          terraform_wrapper: false

      - name: Terraform Init (Bootstrap)
        run: |
          cd {{opsModule.moduleId}}/terraform/bootstrap
          terraform init -input=false

      - name: Terraform Validate (Bootstrap)
        run: |
          cd {{opsModule.moduleId}}/terraform/bootstrap
          terraform validate -no-color

      - name: Clear DynamoDB Locks
        run: |
          echo "üîì Checking for and clearing any Terraform locks..."
          LOCK_TABLE="{{projectName}}-terraform-locks-{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"
          
          # Check if lock table exists
          if aws dynamodb describe-table --table-name "$LOCK_TABLE" >/dev/null 2>&1; then
            echo "üìã DynamoDB lock table exists, checking for locks..."
            
            # Scan for any lock items
            LOCK_ITEMS=$(aws dynamodb scan --table-name "$LOCK_TABLE" --query 'Count' --output text 2>/dev/null || echo "0")
            
            if [ "$LOCK_ITEMS" -gt 0 ]; then
              echo "üîí Found $LOCK_ITEMS lock item(s) in table, clearing them..."
              
              # Get all lock IDs and delete them
              aws dynamodb scan --table-name "$LOCK_TABLE" --query 'Items[].LockID.S' --output text | while read -r LOCK_ID; do
                if [ -n "$LOCK_ID" ]; then
                  echo "  Deleting lock: $LOCK_ID"
                  aws dynamodb delete-item \
                    --table-name "$LOCK_TABLE" \
                    --key '{"LockID":{"S":"'$LOCK_ID'"}}' || true
                fi
              done
              
              echo "‚úÖ Cleared all locks from DynamoDB table"
            else
              echo "‚úÖ No locks found in DynamoDB table"
            fi
          else
            echo "‚úÖ DynamoDB lock table does not exist"
          fi

      - name: Terraform Plan (Bootstrap)
        run: |
          cd {{opsModule.moduleId}}/terraform/bootstrap
          terraform plan -var="environment={{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}" -no-color -input=false

      - name: Terraform Apply (Bootstrap)
        run: |
          cd {{opsModule.moduleId}}/terraform/bootstrap
          echo "üöÄ Applying bootstrap infrastructure..."
          
          # Try apply, but handle "already exists" errors gracefully
          set +e
          APPLY_OUTPUT=$(terraform apply -var="environment={{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}" -auto-approve -input=false 2>&1)
          APPLY_EXIT_CODE=$?
          set -e
          
          echo "$APPLY_OUTPUT"
          
          if [ $APPLY_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Bootstrap apply successful"
          else
            echo "‚ö†Ô∏è Bootstrap apply failed, checking if resources already exist..."
            
            # Check if it's "already exists" errors
            if echo "$APPLY_OUTPUT" | grep -E "(BucketAlreadyOwnedByYou|ResourceInUseException|Table already exists)"; then
              echo "üîÑ Resources already exist, attempting to import them..."
              
              # Import existing S3 bucket
              set +e
              BUCKET_NAME=$(terraform output -raw state_bucket_name 2>/dev/null) || BUCKET_NAME="{{projectName}}-terraform-state"
              terraform import aws_s3_bucket.terraform_state "$BUCKET_NAME" 2>/dev/null
              
              # Import existing DynamoDB table  
              TABLE_NAME=$(terraform output -raw lock_table_name 2>/dev/null) || TABLE_NAME="{{projectName}}-terraform-locks-{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"
              terraform import aws_dynamodb_table.terraform_locks "$TABLE_NAME" 2>/dev/null
              set -e
              
              echo "üîÑ Retrying apply after import..."
              set +e
              terraform apply -var="environment={{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}" -auto-approve -input=false
              RETRY_EXIT_CODE=$?
              set -e
              
              if [ $RETRY_EXIT_CODE -eq 0 ]; then
                echo "‚úÖ Bootstrap apply successful after import"
              else
                echo "‚ö†Ô∏è Apply still failed, but resources may already be configured correctly"
                echo "üìã Checking if we can read outputs..."
                
                # Try to get outputs to verify resources work
                set +e
                terraform output state_bucket_name >/dev/null 2>&1 && terraform output lock_table_name >/dev/null 2>&1
                OUTPUTS_WORK=$?
                set -e
                
                if [ $OUTPUTS_WORK -eq 0 ]; then
                  echo "‚úÖ Resources appear to be working correctly despite apply failure"
                else
                  echo "‚ùå Bootstrap failed and resources don't appear to be working"
                  exit 1
                fi
              fi
            else
              echo "‚ùå Bootstrap failed for unknown reason:"
              echo "$APPLY_OUTPUT"
              exit 1
            fi
          fi

      - name: Create SSL Certificate
        id: create-ssl-cert
        run: |
          echo "üîê Creating SSL certificate for UI domain..."
          
          # Extract configuration with environment-specific prefix
          if [ "${ENVIRONMENT}" = "production" ]; then
            UI_DOMAIN="{{projectName}}-ui.{{sld}}.{{tld}}"
          else
            UI_DOMAIN="{{projectName}}-${ENVIRONMENT}-ui.{{sld}}.{{tld}}"
          fi
          DOMAIN_BASE="{{sld}}.{{tld}}"
          
          echo "UI Domain: $UI_DOMAIN"
          echo "Root Domain: $DOMAIN_BASE"
          
          # Check if certificate already exists
          EXISTING_CERT=$(aws acm list-certificates --region us-east-1 --query "CertificateSummaryList[?DomainName=='$UI_DOMAIN'].CertificateArn" --output text)
          
          if [ -n "$EXISTING_CERT" ] && [ "$EXISTING_CERT" != "None" ]; then
            echo "‚úÖ Certificate already exists: $EXISTING_CERT"
            CERT_ARN="$EXISTING_CERT"
          else
            echo "üîí Creating new SSL certificate..."
            CERT_ARN=$(aws acm request-certificate \
              --region us-east-1 \
              --domain-name "$UI_DOMAIN" \
              --subject-alternative-names "$DOMAIN_BASE" "*.${DOMAIN_BASE}" \
              --validation-method DNS \
              --tags "Key=Name,Value={{projectName}}-ui-certificate" "Key=Environment,Value=${ENVIRONMENT}" "Key=Project,Value={{projectName}}" \
              --query 'CertificateArn' \
              --output text)
            
            echo "‚úÖ Certificate requested: $CERT_ARN"
          fi
          
          # Get validation details with retry mechanism
          echo "üîç Getting DNS validation records..."
          echo "‚è≥ Waiting for AWS to generate DNS validation records..."
          
          # Wait for DNS validation records to be available (max 2 minutes)
          MAX_ATTEMPTS=24  # 24 attempts * 5 seconds = 2 minutes
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "  Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking for DNS validation records..."
            
            # Get the validation options and check if ResourceRecord exists
            VALIDATION_DATA=$(aws acm describe-certificate --region us-east-1 --certificate-arn "$CERT_ARN" \
              --query 'Certificate.DomainValidationOptions[]' --output json)
            
            # Check if validation data exists and if any ResourceRecord is null
            if [ "$VALIDATION_DATA" = "null" ] || [ "$VALIDATION_DATA" = "[]" ] || [ -z "$VALIDATION_DATA" ]; then
              NULL_COUNT=999  # Indicate that validation data is not ready
            else
              NULL_COUNT=$(echo "$VALIDATION_DATA" | jq '[.[] | select(.ResourceRecord == null)] | length' 2>/dev/null || echo "999")
            fi
            
            if [ "$NULL_COUNT" -eq 0 ]; then
              echo "‚úÖ DNS validation records are now available!"
              break
            else
              echo "  Still waiting for DNS records to be generated... ($NULL_COUNT records pending)"
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo "‚ö†Ô∏è Timeout waiting for DNS validation records. They may take a few more minutes to appear."
                echo "üîç You can check manually with:"
                echo "aws acm describe-certificate --region us-east-1 --certificate-arn $CERT_ARN --query 'Certificate.DomainValidationOptions[]'"
                break
              fi
              sleep 5
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          echo "=================================================="
          echo "COPY THESE DNS RECORDS TO YOUR DNS PROVIDER:"
          echo "=================================================="
          
          # Display the validation records with better error handling
          if [ "$VALIDATION_DATA" = "null" ] || [ "$VALIDATION_DATA" = "[]" ] || [ -z "$VALIDATION_DATA" ]; then
            echo "‚ö†Ô∏è DNS validation records are not yet available"
            echo "Domain: $UI_DOMAIN"
            echo "CNAME Name: ‚ö†Ô∏è PENDING - check again in a few minutes"
            echo "CNAME Value: ‚ö†Ô∏è PENDING - check again in a few minutes"
            echo "---"
          else
            echo "$VALIDATION_DATA" | jq -r '.[] | 
              if .ResourceRecord == null then
                "Domain: \(.DomainName)\nCNAME Name: ‚ö†Ô∏è PENDING - check again in a few minutes\nCNAME Value: ‚ö†Ô∏è PENDING - check again in a few minutes\n---"
              else
                "Domain: \(.DomainName)\nCNAME Name: \(.ResourceRecord.Name)\nCNAME Value: \(.ResourceRecord.Value)\n---"
              end' 2>/dev/null || echo "‚ö†Ô∏è Error parsing validation data"
          fi
          
          echo "=================================================="
          echo "‚ö†Ô∏è  IMPORTANT: Add ALL CNAME records above to your DNS provider"
          echo "‚è≥ Certificate will auto-validate once DNS records are added"
          echo "=================================================="
          
          # Save certificate ARN for apply workflow
          echo "üìã UI Certificate ARN: $CERT_ARN"
          echo "UI_CERTIFICATE_ARN=$CERT_ARN" >> $GITHUB_OUTPUT

      - name: Create API SSL Certificate
        id: create-api-ssl-cert
        run: |
          echo "üîê Creating SSL certificate for API domain (ALB - us-west-1)..."
          
          # Extract configuration with environment-specific prefix
          if [ "${ENVIRONMENT}" = "production" ]; then
            API_DOMAIN="{{projectName}}-api.{{sld}}.{{tld}}"
          else
            API_DOMAIN="{{projectName}}-${ENVIRONMENT}-api.{{sld}}.{{tld}}"
          fi
          DOMAIN_BASE="{{sld}}.{{tld}}"
          
          echo "API Domain: $API_DOMAIN"
          echo "Root Domain: $DOMAIN_BASE"
          
          # Check if certificate already exists
          EXISTING_API_CERT=$(aws acm list-certificates --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} --query "CertificateSummaryList[?DomainName=='$API_DOMAIN'].CertificateArn" --output text)
          
          if [ -n "$EXISTING_API_CERT" ] && [ "$EXISTING_API_CERT" != "None" ]; then
            echo "‚úÖ API Certificate already exists: $EXISTING_API_CERT"
            API_CERT_ARN="$EXISTING_API_CERT"
          else
            echo "üîí Creating new API SSL certificate..."
            API_CERT_ARN=$(aws acm request-certificate \
              --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} \
              --domain-name "$API_DOMAIN" \
              --subject-alternative-names "$DOMAIN_BASE" "*.${DOMAIN_BASE}" \
              --validation-method DNS \
              --tags "Key=Name,Value={{projectName}}-api-certificate" "Key=Environment,Value=${ENVIRONMENT}" "Key=Project,Value={{projectName}}" \
              --query 'CertificateArn' \
              --output text)
            
            echo "‚úÖ API Certificate requested: $API_CERT_ARN"
          fi
          
          # Get validation details with retry mechanism
          echo "üîç Getting API DNS validation records..."
          echo "‚è≥ Waiting for AWS to generate API DNS validation records..."
          
          # Wait for DNS validation records to be available (max 2 minutes)
          MAX_ATTEMPTS=24  # 24 attempts * 5 seconds = 2 minutes
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "  Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking for API DNS validation records..."
            
            # Get the validation options and check if ResourceRecord exists
            API_VALIDATION_DATA=$(aws acm describe-certificate --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} --certificate-arn "$API_CERT_ARN" \
              --query 'Certificate.DomainValidationOptions[]' --output json)
            
            # Check if validation data exists and if any ResourceRecord is null
            if [ "$API_VALIDATION_DATA" = "null" ] || [ "$API_VALIDATION_DATA" = "[]" ] || [ -z "$API_VALIDATION_DATA" ]; then
              NULL_COUNT=999  # Indicate that validation data is not ready
            else
              NULL_COUNT=$(echo "$API_VALIDATION_DATA" | jq '[.[] | select(.ResourceRecord == null)] | length' 2>/dev/null || echo "999")
            fi
            
            if [ "$NULL_COUNT" -eq 0 ]; then
              echo "‚úÖ API DNS validation records are now available!"
              break
            else
              echo "  Still waiting for API DNS records to be generated... ($NULL_COUNT records pending)"
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo "‚ö†Ô∏è Timeout waiting for API DNS validation records. They may take a few more minutes to appear."
                break
              fi
              sleep 5
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          # Save certificate ARN for apply workflow
          echo "üìã API Certificate ARN: $API_CERT_ARN"
          echo "API_CERTIFICATE_ARN=$API_CERT_ARN" >> $GITHUB_OUTPUT

      - name: Display All DNS Records
        run: |
          echo "=================================================="
          echo "üîê ALL DNS VALIDATION RECORDS TO ADD:"
          echo "=================================================="
          echo ""
          echo "--- UI CERTIFICATE (CloudFront - us-east-1) ---"
          
          # Get UI cert validation data
          UI_CERT_ARN="{{{githubVarsOpen}}} steps.create-ssl-cert.outputs.UI_CERTIFICATE_ARN  {{{githubVarsClose}}}"
          
          echo "Getting UI certificate validation data..."
          UI_VALIDATION_DATA=$(aws acm describe-certificate --region us-east-1 --certificate-arn "$UI_CERT_ARN" \
            --query 'Certificate.DomainValidationOptions[]' --output json 2>/dev/null || echo '[]')
          
          if [ "$UI_VALIDATION_DATA" = "[]" ] || [ "$UI_VALIDATION_DATA" = "null" ] || [ -z "$UI_VALIDATION_DATA" ]; then
            echo "‚ö†Ô∏è No UI validation data available yet"
          else
            echo "$UI_VALIDATION_DATA" | jq -r '.[] | 
              if .ResourceRecord == null then
                "Domain: \(.DomainName)\nCNAME Name: ‚ö†Ô∏è PENDING - check again in a few minutes\nCNAME Value: ‚ö†Ô∏è PENDING - check again in a few minutes\n"
              else
                "Domain: \(.DomainName)\nCNAME Name: \(.ResourceRecord.Name)\nCNAME Value: \(.ResourceRecord.Value)\n"
              end' 2>/dev/null || echo "‚ö†Ô∏è Error parsing UI validation data"
          fi
          
          echo "--- API CERTIFICATE (ALB - {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}) ---"
          
          # Get API cert validation data
          API_CERT_ARN="{{{githubVarsOpen}}} steps.create-api-ssl-cert.outputs.API_CERTIFICATE_ARN  {{{githubVarsClose}}}"
          
          echo "Getting API certificate validation data..."
          API_VALIDATION_DATA=$(aws acm describe-certificate --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} --certificate-arn "$API_CERT_ARN" \
            --query 'Certificate.DomainValidationOptions[]' --output json 2>/dev/null || echo '[]')
          
          if [ "$API_VALIDATION_DATA" = "[]" ] || [ "$API_VALIDATION_DATA" = "null" ] || [ -z "$API_VALIDATION_DATA" ]; then
            echo "‚ö†Ô∏è No API validation data available yet"
          else
            echo "$API_VALIDATION_DATA" | jq -r '.[] | 
              if .ResourceRecord == null then
                "Domain: \(.DomainName)\nCNAME Name: ‚ö†Ô∏è PENDING - check again in a few minutes\nCNAME Value: ‚ö†Ô∏è PENDING - check again in a few minutes\n"
              else
                "Domain: \(.DomainName)\nCNAME Name: \(.ResourceRecord.Name)\nCNAME Value: \(.ResourceRecord.Value)\n"
              end' 2>/dev/null || echo "‚ö†Ô∏è Error parsing API validation data"
          fi
          
          echo "=================================================="
          {{!-- PLACEHOLDER: dns-provider-message --}}
          echo "=================================================="

      - name: Auto-Manage DNS Records
        id: auto-dns
        run: |
          {{!-- PLACEHOLDER: dns-auto-manage --}}
      - name: Output Bootstrap Results
        run: |
          cd {{opsModule.moduleId}}/terraform/bootstrap
          echo "## Terraform Bootstrap Completed ‚úÖ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**State Bucket:** $(terraform output -raw state_bucket_name)" >> $GITHUB_STEP_SUMMARY
          echo "**Lock Table:** $(terraform output -raw lock_table_name)" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** $(terraform output -raw aws_region)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## SSL Certificates Created üîê" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**UI Domain:** {{projectName}}-ui.{{sld}}.{{tld}} (CloudFront - us-east-1)" >> $GITHUB_STEP_SUMMARY
          echo "**UI Certificate ARN:** {{{githubVarsOpen}}} steps.create-ssl-cert.outputs.UI_CERTIFICATE_ARN  {{{githubVarsClose}}}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**API Domain:** {{projectName}}-api.{{sld}}.{{tld}} (ALB - {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}})" >> $GITHUB_STEP_SUMMARY
          echo "**API Certificate ARN:** {{{githubVarsOpen}}} steps.create-api-ssl-cert.outputs.API_CERTIFICATE_ARN  {{{githubVarsClose}}}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add DNS management status
          if [ "{{{githubVarsOpen}}} steps.auto-dns.outputs.DNS_AUTO_MANAGED  {{{githubVarsClose}}}" = "true" ]; then
            echo "## DNS Records Auto-Managed ‚úÖ" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Provider:** {{{githubVarsOpen}}} env.DNS_PROVIDER  {{{githubVarsClose}}}" >> $GITHUB_STEP_SUMMARY
            echo "**Status:** DNS validation records were automatically added to your DNS provider" >> $GITHUB_STEP_SUMMARY
            echo "**Note:** Certificates will auto-validate once DNS propagation completes" >> $GITHUB_STEP_SUMMARY
          else
            echo "## DNS Records Management ‚ö†Ô∏è" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Status:** Manual DNS management required" >> $GITHUB_STEP_SUMMARY
            echo "**‚ö†Ô∏è IMPORTANT: Add ALL DNS validation records shown above to your DNS provider!**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "You can now run the main Terraform deployment workflow." >> $GITHUB_STEP_SUMMARY