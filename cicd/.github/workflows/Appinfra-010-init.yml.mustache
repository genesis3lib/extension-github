name: Appinfra-010-Init

on:
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: {{region}}
  AWS_ACCESS_KEY_ID: {{{githubVarsOpen}}} vars.AWS_ADMIN_ID {{{githubVarsClose}}}

jobs:
  init:
    name: Init
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Environment
        uses: ./.github/actions/setup-environment

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: {{{githubVarsOpen}}} env.AWS_ACCESS_KEY_ID {{{githubVarsClose}}}
          aws-secret-access-key: {{{githubVarsOpen}}} secrets.AWS_ADMIN_SECRET {{{githubVarsClose}}}
          aws-region: {{{githubVarsOpen}}} env.AWS_REGION {{{githubVarsClose}}}

      - name: Create Permissions Boundary for Terraform Role
        run: |
          echo "üõ°Ô∏è Creating permissions boundary to limit privilege escalation..."

          # Create permissions boundary policy that blocks dangerous operations
          cat > /tmp/terraform-permissions-boundary.json <<'EOF'
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "AllowMostActions",
                "Effect": "Allow",
                "Action": "*",
                "Resource": "*"
              },
              {
                "Sid": "DenyIAMUserCreation",
                "Effect": "Deny",
                "Action": [
                  "iam:CreateUser",
                  "iam:CreateLoginProfile",
                  "iam:UpdateLoginProfile",
                  "iam:CreateAccessKey",
                  "iam:CreateServiceSpecificCredential"
                ],
                "Resource": "*"
              },
              {
                "Sid": "DenyBoundaryModification",
                "Effect": "Deny",
                "Action": [
                  "iam:DeleteRolePermissionsBoundary",
                  "iam:DeleteUserPermissionsBoundary",
                  "iam:PutRolePermissionsBoundary",
                  "iam:PutUserPermissionsBoundary"
                ],
                "Resource": "*"
              },
              {
                "Sid": "DenyOrganizationAccess",
                "Effect": "Deny",
                "Action": [
                  "organizations:*",
                  "account:*"
                ],
                "Resource": "*"
              },
              {
                "Sid": "DenyBillingAccess",
                "Effect": "Deny",
                "Action": [
                  "aws-portal:*",
                  "budgets:ModifyBudget",
                  "ce:*",
                  "cur:*"
                ],
                "Resource": "*"
              },
              {
                "Sid": "DenyCloudTrailTampering",
                "Effect": "Deny",
                "Action": [
                  "cloudtrail:DeleteTrail",
                  "cloudtrail:StopLogging",
                  "cloudtrail:UpdateTrail",
                  "cloudtrail:PutEventSelectors"
                ],
                "Resource": "*"
              },
              {
                "Sid": "DenyGuardDutyTampering",
                "Effect": "Deny",
                "Action": [
                  "guardduty:DeleteDetector",
                  "guardduty:DisassociateFromMasterAccount",
                  "guardduty:UpdateDetector"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF

          BOUNDARY_NAME="{{projectName}}-terraform-boundary"
          BOUNDARY_ARN="arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:policy/${BOUNDARY_NAME}"

          # Create or update the permissions boundary policy
          if aws iam get-policy --policy-arn "$BOUNDARY_ARN" 2>/dev/null; then
            echo "Updating existing permissions boundary..."
            # Get current version and create new version
            VERSIONS=$(aws iam list-policy-versions --policy-arn "$BOUNDARY_ARN" --query 'Versions[?IsDefaultVersion==`false`].VersionId' --output text)
            # Delete old non-default versions if we have 5 (AWS limit)
            VERSION_COUNT=$(aws iam list-policy-versions --policy-arn "$BOUNDARY_ARN" --query 'length(Versions)')
            if [ "$VERSION_COUNT" -ge 5 ]; then
              OLDEST=$(aws iam list-policy-versions --policy-arn "$BOUNDARY_ARN" --query 'Versions[?IsDefaultVersion==`false`] | sort_by(@, &CreateDate) | [0].VersionId' --output text)
              aws iam delete-policy-version --policy-arn "$BOUNDARY_ARN" --version-id "$OLDEST"
            fi
            aws iam create-policy-version --policy-arn "$BOUNDARY_ARN" --policy-document file:///tmp/terraform-permissions-boundary.json --set-as-default
          else
            echo "Creating new permissions boundary..."
            aws iam create-policy \
              --policy-name "$BOUNDARY_NAME" \
              --policy-document file:///tmp/terraform-permissions-boundary.json \
              --description "Permissions boundary for {{projectName}} Terraform role - prevents privilege escalation"
          fi

          echo "‚úÖ Permissions boundary ready: $BOUNDARY_ARN"

      - name: Create Trust Policy and Roles needed for All other github actions
        run: |
          echo "üîê Setting up GitHub OIDC Identity Provider and IAM roles..."

          # Create GitHub OIDC Identity Provider (if it doesn't exist)
          if ! aws iam get-open-id-connect-provider --open-id-connect-provider-arn "arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:oidc-provider/token.actions.githubusercontent.com" 2>/dev/null; then
            echo "Creating GitHub OIDC Identity Provider..."
            aws iam create-open-id-connect-provider \
              --url https://token.actions.githubusercontent.com \
              --client-id-list sts.amazonaws.com \
              --thumbprint-list 6938fd4d98bab03faadb97b34396831e3780aea1 \
              --thumbprint-list 1c58a3a8518e8759bf075b76b750d4f2df264fcd
          else
            echo "GitHub OIDC Identity Provider already exists"
          fi
          
          # Get repository information from GitHub context
          REPO_OWNER="{{{githubVarsOpen}}} github.repository_owner {{{githubVarsClose}}}"
          REPO_NAME="{{{githubVarsOpen}}} github.event.repository.name {{{githubVarsClose}}}"
          
          echo "Repository: ${REPO_OWNER}/${REPO_NAME}"
          
          # Create trust policy for GitHub Actions
          cat > /tmp/github-trust-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Federated": "arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:oidc-provider/token.actions.githubusercontent.com"
                },
                "Action": "sts:AssumeRoleWithWebIdentity",
                "Condition": {
                  "StringEquals": {
                    "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"
                  },
                  "StringLike": {
                    "token.actions.githubusercontent.com:sub": "repo:${REPO_OWNER}/${REPO_NAME}:*"
                  }
                }
              }
            ]
          }
          EOF
          
          # 1. Create Terraform Role for Infrastructure Operations
          echo "üèóÔ∏è Creating Terraform role..."
          cat > /tmp/terraform-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "ec2:*",
                  "rds:*",
                  "s3:*",
                  "cloudfront:*",
                  "elasticloadbalancing:*",
                  "autoscaling:*",
                  "iam:*",
                  "secretsmanager:*",
                  "ssm:*",
                  "logs:*",
                  "route53:*",
                  "acm:*",
                  "dynamodb:*",
                  "cloudwatch:*"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF
          
          # Create or update terraform role with permissions boundary
          BOUNDARY_ARN="arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:policy/{{projectName}}-terraform-boundary"

          if aws iam get-role --role-name "{{projectName}}-terraform-role" 2>/dev/null; then
            echo "Updating existing terraform role..."
            aws iam update-assume-role-policy \
              --role-name "{{projectName}}-terraform-role" \
              --policy-document file:///tmp/github-trust-policy.json
            # Attach permissions boundary to existing role
            aws iam put-role-permissions-boundary \
              --role-name "{{projectName}}-terraform-role" \
              --permissions-boundary "$BOUNDARY_ARN"
          else
            echo "Creating new terraform role with permissions boundary..."
            aws iam create-role \
              --role-name "{{projectName}}-terraform-role" \
              --assume-role-policy-document file:///tmp/github-trust-policy.json \
              --permissions-boundary "$BOUNDARY_ARN" \
              --description "Role for Terraform infrastructure operations via GitHub Actions"
          fi

          aws iam put-role-policy \
            --role-name "{{projectName}}-terraform-role" \
            --policy-name "TerraformFullAccess" \
            --policy-document file:///tmp/terraform-policy.json

          echo "‚úÖ Terraform role configured with permissions boundary"
          
          # 2. Create S3 Deployment Role for Client Operations
          echo "üåê Creating S3 deployment role..."
          cat > /tmp/s3-deploy-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "s3:ListAllMyBuckets"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "s3:GetObject",
                  "s3:PutObject",
                  "s3:DeleteObject",
                  "s3:ListBucket",
                  "s3:GetBucketLocation",
                  "s3:GetBucketVersioning",
                  "s3:PutBucketVersioning",
                  "s3:GetBucketAcl",
                  "s3:PutBucketAcl",
                  "s3:GetBucketPolicy",
                  "s3:PutBucketPolicy",
                  "s3:DeleteBucketPolicy"
                ],
                "Resource": [
                  "arn:aws:s3:::*{{projectName}}*",
                  "arn:aws:s3:::*{{projectName}}*/*"
                ]
              },
              {
                "Effect": "Allow",
                "Action": [
                  "cloudfront:CreateInvalidation",
                  "cloudfront:GetInvalidation",
                  "cloudfront:ListInvalidations",
                  "cloudfront:GetDistribution",
                  "cloudfront:GetDistributionConfig",
                  "cloudfront:ListDistributions"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF
          
          aws iam create-role \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-s3-role" \
            --assume-role-policy-document file:///tmp/github-trust-policy.json \
            --description "Role for S3 and CloudFront operations via GitHub Actions ({{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}})" || \
          aws iam update-assume-role-policy \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-s3-role" \
            --policy-document file:///tmp/github-trust-policy.json
          
          aws iam put-role-policy \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-s3-role" \
            --policy-name "S3CloudFrontAccess" \
            --policy-document file:///tmp/s3-deploy-policy.json
          
          # 3. Create EC2 Deployment Role for Server Operations
          echo "üñ•Ô∏è Creating EC2 deployment role..."
          cat > /tmp/ec2-deploy-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "s3:ListAllMyBuckets"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "s3:GetObject",
                  "s3:PutObject",
                  "s3:ListBucket"
                ],
                "Resource": [
                  "arn:aws:s3:::*{{projectName}}*",
                  "arn:aws:s3:::*{{projectName}}*/*",
                  "arn:aws:s3:::{{projectName}}-*-api",
                  "arn:aws:s3:::{{projectName}}-*-api/*",
                  "arn:aws:s3:::{{projectName}}-*-ops", 
                  "arn:aws:s3:::{{projectName}}-*-ops/*"
                ]
              },
              {
                "Effect": "Allow",
                "Action": [
                  "ssm:SendCommand",
                  "ssm:GetCommandInvocation",
                  "ssm:DescribeInstanceInformation",
                  "ssm:DescribeInstances",
                  "ssm:ListCommands",
                  "ssm:ListCommandInvocations",
                  "ssm:GetParameter",
                  "ssm:GetParameters",
                  "ssm:GetParameterHistory"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "ec2:DescribeInstances",
                  "ec2:DescribeInstanceStatus",
                  "ec2:DescribeInstanceAttribute",
                  "ec2:DescribeTags"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "autoscaling:DescribeAutoScalingGroups",
                  "autoscaling:DescribeAutoScalingInstances",
                  "autoscaling:DescribeLaunchConfigurations",
                  "autoscaling:UpdateAutoScalingGroup"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "elasticloadbalancing:DescribeTargetGroups",
                  "elasticloadbalancing:DescribeTargetHealth"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF

          aws iam create-role \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-ec2-role" \
            --assume-role-policy-document file:///tmp/github-trust-policy.json \
            --description "Role for EC2 and SSM operations via GitHub Actions ({{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}})" || \
          aws iam update-assume-role-policy \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-ec2-role" \
            --policy-document file:///tmp/github-trust-policy.json
          
          aws iam put-role-policy \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-ec2-role" \
            --policy-name "EC2SSMAccess" \
            --policy-document file:///tmp/ec2-deploy-policy.json
          
          echo "‚úÖ Successfully created all IAM roles and policies:"
          echo "   - {{projectName}}-terraform-role (Infrastructure operations)"
          echo "     ‚îî‚îÄ‚îÄ üõ°Ô∏è Protected by permissions boundary: {{projectName}}-terraform-boundary"
          echo "   - {{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-s3-role (Client deployments)"
          echo "   - {{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-ec2-role (Server deployments)"

          echo "üîç Listing created roles:"
          aws iam list-roles --query 'Roles[?contains(RoleName, `{{projectName}}`)].{RoleName:RoleName,Arn:Arn}' --output table

          echo "üõ°Ô∏è Permissions boundary blocks:"
          echo "   - IAM user/access key creation (no backdoor accounts)"
          echo "   - Boundary policy modification (boundary cannot be removed)"
          echo "   - Organization/account level changes"
          echo "   - Billing access modification"
          echo "   - CloudTrail/GuardDuty tampering (audit logs protected)"

      - name: Check and Generate SSH Keys
        run: |
          echo "üîë Checking SSH keys in S3 terraform-state bucket..."

          # Determine the terraform state bucket name (includes AWS account ID for global uniqueness)
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          STATE_BUCKET="{{projectName}}-tfstate-${AWS_ACCOUNT_ID}"
          
          echo "Checking for SSH keys in bucket: $STATE_BUCKET"
          
          # Check if the bucket exists
          if ! aws s3api head-bucket --bucket "$STATE_BUCKET" 2>/dev/null; then
            echo "‚ö†Ô∏è Terraform state bucket $STATE_BUCKET doesn't exist yet"
            echo "SSH keys will be generated during bootstrap phase"
            exit 0
          fi
          
          # Check if ssh directory and keys exist for current environment
          CURRENT_ENV="{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}"
          echo "üîç Checking for existing SSH keys for environment: $CURRENT_ENV"
          
          MISSING_KEYS=()
          
          # Check for environment-specific keys
          if ! aws s3 ls "s3://$STATE_BUCKET/ssh/${CURRENT_ENV}_key" >/dev/null 2>&1; then
            echo "‚ùå ${CURRENT_ENV} SSH key not found"
            MISSING_KEYS+=("$CURRENT_ENV")
          else
            echo "‚úÖ ${CURRENT_ENV} SSH key found"
          fi
          
          if ! aws s3 ls "s3://$STATE_BUCKET/ssh/${CURRENT_ENV}_key.pub" >/dev/null 2>&1; then
            echo "‚ùå ${CURRENT_ENV} SSH public key not found"
            MISSING_KEYS+=("$CURRENT_ENV")
          else
            echo "‚úÖ ${CURRENT_ENV} SSH public key found"
          fi
          
          # Generate missing keys
          if [ ${#MISSING_KEYS[@]} -eq 0 ]; then
            echo "‚úÖ All SSH keys are present in S3"
          else
            echo "üîë Generating missing SSH keys..."
            
            # Create temporary directory for key generation
            TEMP_DIR=$(mktemp -d)
            cd "$TEMP_DIR"
            
            # Remove duplicates from MISSING_KEYS array
            UNIQUE_MISSING=($(printf "%s\n" "${MISSING_KEYS[@]}" | sort -u))
            
            for ENV in "${UNIQUE_MISSING[@]}"; do
              echo "Generating SSH key pair for ${ENV} environment..."
              
              # Generate SSH key pair
              ssh-keygen -t rsa -b 4096 -f "${ENV}_key" -N "" -C "{{projectName}}-${ENV}"
              
              echo "‚úÖ Generated ${ENV}_key and ${ENV}_key.pub"
              
              # Upload to S3
              echo "üì§ Uploading ${ENV} SSH keys to S3..."
              aws s3 cp "${ENV}_key" "s3://$STATE_BUCKET/ssh/${ENV}_key"
              aws s3 cp "${ENV}_key.pub" "s3://$STATE_BUCKET/ssh/${ENV}_key.pub"
              
              echo "‚úÖ Uploaded ${ENV} SSH keys to s3://$STATE_BUCKET/ssh/"
            done
            
            # Cleanup temporary directory
            cd /
            rm -rf "$TEMP_DIR"
            echo "üßπ Cleaned up temporary files"
          fi
          
          echo "üîç Final SSH key inventory in S3:"
          aws s3 ls "s3://$STATE_BUCKET/ssh/" || echo "No ssh directory found in S3"
          
          echo "üìù Note: S3 ops buckets will be created by Terraform during deploy_apply operation"